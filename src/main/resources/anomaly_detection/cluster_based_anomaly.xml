<?xml version="1.0" encoding="UTF-8"?>
<?xml-stylesheet type="text/xsl" href="../../../../../rapidminerreferencemanual/documentation2html.xsl"?>
<p1:documents xmlns:p1="http://rapid-i.com/schemas/documentation/reference/1.0"
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://rapid-i.com/schemas/documentation/reference/1.0 ">

    <operator key="operator.anomaly_detection:cluster_based_anomaly" locale="en"
              version="6.0.000">
        <title>Detect Outlier (Clustering)</title>
        <synopsis>This operator is allows you to use cluster based methods for anomaly detection. It currently supports
            CBLOF, CMGOS and LDCOF
        </synopsis>
        <text>
            <paragraph>CBLOF (Cluster-Based Local Outlier Factor):
                Calculates the outlier score based on cluster-based local
                outlier factor proposed by He et al [2003].

                CBLOF takes as an input the data set and the cluster model that was
                generated by a clustering algorithm. It categorizes the clusters
                into small clusters and large clusters using the parameters alpha
                and beta.

                The anomaly score is then calculated based on the size of the
                cluster the point belongs to as well as the distance to the nearest
                large cluster centroid.

                It uses weighting for CBLOF based on the sizes of the clusters as
                proposed in the original publication. Since this might lead to
                unexpected behavior (outliers close to small clusters are not found),
                it can be disabled and outliers scores are solely computed based on
                their distance to the cluster center.
            </paragraph>
            <paragraph>CMGOS (Clustering-based Multivariate Gaussian Outlier Score):
                Calculates the outlier score based on a clustering result. The
                outlier score of an instance depends on the probability of how likely
                its distance to the cluster center is.

                This algorithm takes as input a clustered data set and a cluster model
                containing its centroids. Then, an outlier score is calculated on the
                basis of the centroid and the multivariate Gaussian of the cluster.
                Therefore, a covariance matrix of the multivariate Gaussian of each
                cluster is computed. Since covariance matrices are sensitive to outliers,
                different robust estimators exist, whereas this operator has
                different strategies: (1) Compute covariance matrix, remove outliers
                according to expected percentage and recompute covariance matrix.
                Basically this could be understood as a multivariate Grubb's Test.
                To cope with the challenge of not invertable matrices, two different
                sub-strategies have been implemented (1a) Reduction - reduces the number
                of dimensions by selecting only dimensions for each cluster which have
                at least two different values and (1a) Regularization - regularizes the covariance
                matrix with lambda (c.f. Friedman, J.H. (1989): Regularized Discriminant Analysis).
                (3) A robust covariance estimation according to
                Minimum Covariance Determinant (MCD) by Rousseeuw and Van Driessen as described in
                &quot;A Fast Algorithm for the Minimum Covariance Determinant Estimator&quot;,
                1999, has been implemented. Although the fastMCD was implemented, this
                algorithm is comparable slow.
            </paragraph>
            <paragraph>
                LDCOF (Local Density Cluster-Based Outlier Factor):
                This is a local density based anomaly detection algorithm. The
                anomaly score is set to the distance to the nearest large cluster
                divided by the average cluster distance of the large cluster. The
                intuition behind this is that the small clusters are considered
                outlying and thus they are assigned to the nearest large cluster and
                this becomes its local neighborhood. The division into large and
                small clusters can be either done similar to what was implemented
                in the CBLOF paper (He et al,2003) or it can done in a manner
                similar to what was proposed in (Moh&#39;d Belal Al- Zoubi,2009).
                This is determined by the parameter &quot; divide clusters like
                CBLOF
            </paragraph>
        </text>
<!--        <inputPorts>-->
<!--            <port name="input" type="com.rapidminer.example.ExampleSet">-->
<!--                Input port description.-->
<!--            </port>-->
<!--        </inputPorts>-->
<!--        <outputPorts>-->
<!--            <port name="output" type="com.rapidminer.example.ExampleSet">-->
<!--                Output port description.-->
<!--            </port>-->
<!--        </outputPorts>-->

<!--        &lt;!&ndash; description of the parameters and the corresponding values &ndash;&gt;-->
<!--        <parameters>-->
<!--            <parameter key="first_parameter" type="configurable">-->
<!--                Description here-->
<!--            </parameter>-->
<!--            <parameter key="second_parameter" type="selection">-->
<!--                Description here-->
<!--            </parameter>-->
<!--            <parameter key="third_parameter" type="">-->
<!--                Description here-->
<!--            </parameter>-->
<!--        </parameters>-->

<!--        <tutorialProcesses>-->
<!--            <tutorialProcess key="process.python.clustering" title="Clustering using Python">-->
<!--                <description>-->
<!--                    <paragraph>-->
<!--                        Tutorial description here.-->
<!--                    </paragraph>-->
<!--                </description>-->
<!--                <process version="6.4.000">-->
<!--                    <context>-->
<!--                        <input/>-->
<!--                        <output/>-->
<!--                        <macros/>-->
<!--                    </context>-->
<!--                    <operator activated="true" class="process" compatibility="6.4.000" expanded="true" name="Process">-->
<!--                        <process expanded="true">-->
<!--                            <operator activated="true" class="retrieve" compatibility="6.4.000" expanded="true" height="60" name="Retrieve Iris" width="90" x="380" y="210">-->
<!--                                <parameter key="repository_entry" value="//Samples/data/Iris"/>-->
<!--                            </operator>-->
<!--                            <connect from_op="Retrieve Iris" from_port="output" to_port="result 1"/>-->
<!--                            <portSpacing port="source_input 1" spacing="0"/>-->
<!--                            <portSpacing port="sink_result 1" spacing="0"/>-->
<!--                            <portSpacing port="sink_result 2" spacing="0"/>-->
<!--                        </process>-->
<!--                    </operator>-->
<!--                </process>-->
<!--            </tutorialProcess>-->
<!--        </tutorialProcesses>-->

        <relatedDocuments>
            <!-- ... -->
        </relatedDocuments>
    </operator>
</p1:documents>
